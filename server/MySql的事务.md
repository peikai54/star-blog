## MySql 中的事务

为了避免多个 sql 执行时操作失败导致的数据不一致的问题，批量执行部分 sql 时可以使用事务来执行。

事务的特点 : **ACID**

### 事务特性

#### 事务的原子性

个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作。这是事务能保证数据一致性的重要前提

#### 事务的一致性

数据库总是从一个一致性状态转换到另一个一致状态。也就是收事务的 sql 在提交之前，不会对数据形成真正的影响。

#### 事务的持久性

一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。

#### 事务的隔离性

事务提交之前，对其他事务来说通常是不可见的。但这个其实与事务的隔离等级有关。

### 事务的隔离级别

为什么事务需要隔离？原因在于事务并发时，会引起脏读、不可重复读、幻读等问题，导致数据错误。现在我们用表 user 来举例说明一下这几个并发问题。

#### 脏读

脏读是指读到了其他事务未提交的数据，可能导致读取数据错误。假设我们有两个事务，事务 A 和事务 B。事务 A 将 user 表中的用户张三的年龄从 19 改成 20， 这时事务 B 读张三的年龄，结果是 20。但因为事务 A 发生了错误，事务 A 被回滚，张三的年龄回到了 19。这时事务 B 读到的就是脏数据。

#### 不可重复读

假设事务 A 要读两次 user 张三的年龄，事务 A 第一次读取时，张三是 19 岁。但在事务 A 第一次读取完毕后，事务 B 将张三的年龄修改成 20 了。事务 B 成功提交后，事务 A 有一次读取了张三的年龄，发现张三年龄变成 20 了，在同一个事务内两次读取一条数据结果不一样，便可能引致错误。这就是并发时的不可重复读问题。

#### 幻读

假设事务 A 要读两次 user 表的总量，第一次读时，user 表一共有二十条数据。但在第一次读取后，事务 B 给 user 表查了 10 条数据。事务 B 成功提交后，事务 A 再次读取了 user 表数据，变成了 20 条，前后读取的总量不一致，便引起了幻读问题。

脏读针对的是并发时读到未提交的数据，在事务回滚后数据与真实数据不一致。不可重复读针对并发时，读到其他事务修改前和修改后的数据，导致数据不一致。幻读跟不可重复读类似，但针对的是数据的总量，计算总量时可能读到别人插入或删除前后的数据导致总量不一致。

那么事务隔离是怎么避免这三个问题的呢：

#### 事务隔离界别；读未提交

不做隔离，可以读到别人没提交的数据，也就是说什么都没解决。

#### 事务隔离级别：读已提交

事务提交前不允许被读。这样自然避免了脏读的问题，但无法避免幻读和不可重复读。

#### 可重复读。

只要事务开始读取某个数据，就不再允许其他事务在该事务提交之前修改该数据，避免了不可重复读的问题。

#### 串行化

事务一个一个串行执行，自然避免了并发中的所有问题。串行化可避免脏读、不可重复读与幻读。
